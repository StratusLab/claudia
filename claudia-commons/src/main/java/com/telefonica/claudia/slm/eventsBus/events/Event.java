/*
* Claudia Project
* http://claudia.morfeo-project.org
*
* (C) Copyright 2010 Telefonica Investigacion y Desarrollo
* S.A.Unipersonal (Telefonica I+D)
*
* See CREDITS file for info about members and contributors.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the Affero GNU General Public License (AGPL) as 
* published by the Free Software Foundation; either version 3 of the License, 
* or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the Affero GNU General Public License
* along with this program; if not, write to the Free Software
* Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
*
* If you want to use this software an plan to distribute a
* proprietary application in any way, and you are not licensing and
* distributing your source code under AGPL, you probably need to
* purchase a commercial license of the product. Please contact
* claudia-support@lists.morfeo-project.org for more information.
*/
/** Class that defines events to be generated/consumed by 
 * Service Manager components.
 */

package com.telefonica.claudia.slm.eventsBus.events;

import java.io.Serializable;

public class Event implements Serializable {
    
	private static final long serialVersionUID = 1L;

	/** There are seven different types of events:
     * SERVICE_SLA_VIOLATION_EVENT - Generated by the SLA Protection Rule
     * Engine.
     * INFRASTRUCTURE_SLA_VIOLATION_EVENT - Generated by the Policy Engine 
     * in the VEEM.
     * VEE_HW_MEASUREMENT - Gererated by hypervisors at the VEEs.
     * AGENT_MEASUREMENT - Generated by agents running inside the Service
     * Software running in the VEEs.
     * PROBE_MEASUREMENT - Generated by Probes.
     * SM_CONTROL_EVENT - Generated by SM components to let the Lifecycle controller know about changes in their statuses
     */
    public static enum EventType { SERVICE_SLA_VIOLATION_EVENT,
                            INFRASTRUCTURE_SLA_VIOLATION_EVENT,
                            VEE_HW_MEASUREMENT,
                            AGENT_MEASUREMENT,
                            PROBE_MEASUREMENT,
                            SM_CONTROL_EVENT,
                            SMI_CHANNEL_EVENT,
                            ADMINISTRATIVE_EVENT,
                            FSM_BUS_EVENT};
    
    /** 
     * In the JMS system, there is a topic (bus channel) per each event type. 
     * This method returns the topic name corresponding to each event type.
     * 
     * @param Type of event to return its corresponding topic name.
     * @return The topic (channel) name.
     */
    public static String busTopicForEventType(EventType eventType){
        
        switch(eventType) {
            case SERVICE_SLA_VIOLATION_EVENT:
                return EventType.SERVICE_SLA_VIOLATION_EVENT.toString();
            case INFRASTRUCTURE_SLA_VIOLATION_EVENT:
                return EventType.INFRASTRUCTURE_SLA_VIOLATION_EVENT.toString();
            case VEE_HW_MEASUREMENT:
                return EventType.VEE_HW_MEASUREMENT.toString();
            case AGENT_MEASUREMENT:
                return EventType.AGENT_MEASUREMENT.toString();
            case PROBE_MEASUREMENT:
                return EventType.PROBE_MEASUREMENT.toString();
            case SM_CONTROL_EVENT:
                return EventType.SM_CONTROL_EVENT.toString();
            case SMI_CHANNEL_EVENT:
                return EventType.SMI_CHANNEL_EVENT.toString();
            case FSM_BUS_EVENT:
                return EventType.FSM_BUS_EVENT.toString();
            default:
                throw new Error("Unkonwn event type???");
        }
    }
                     
    /**
     * In the case of the SMI Channel, the events are not distributed over a Topic, but
     * over a Queue. This way, there are two identifieres needed: the one for the request queue
     * and the one for the reply queue. This method returns the appropiate name for the chosen queue
     */
    public static String busQueueForEventType(EventType eventType, boolean reply) {
        switch(eventType) {
	        case SMI_CHANNEL_EVENT:
	        case ADMINISTRATIVE_EVENT:	
	        	if (reply)
	        		return eventType.toString() + "_REPLY";
	        	else
	        		return eventType.toString() + "_REQUEST";
	        default:
	        	throw new Error("Unkonwn event type???");
        }
    }
    
    /** Time associated to the event. For a VEEHw, Agent or Probe monitoring event,
     * it is the time the data was generated, for a SLA violation, is the time the
     * violation happened. */
    private long t_0 = 0;
    /** Delta 0. Used for aggregated data, it is the length of the time interval of
     * the aggregation. */
    private long delta_t = 0;
    /** Event type */
    private EventType type = null;
    
    /**
     * Constructor of events. No event with empty field is allowed.
     * @param t_0 Time the event creator started running.
     * @param delta_t Elapsed time since t_0 until the event creation.
     * event FQN.
     * @param type Event type. 
     */
    protected Event(long t_0, long delta_t, EventType type){
        this.t_0 = t_0;
        this.delta_t = delta_t;
        this.type = type;
    }
    
    public long getInitialTime() {
        return t_0;
    }
    
    public long getDeltaT() {
        return delta_t;
    }
    
    public EventType getEventType(){
        return type;
    }
    
    @Override
    public String toString(){
        return "t_0:" + t_0
                + " t:" + delta_t
                + " type:" + type;
    }
    
}
